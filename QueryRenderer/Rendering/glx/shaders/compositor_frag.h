#ifndef QUERYRENDERER_GLX_COMPOSITORFRAG_H_
#define QUERYRENDERER_GLX_COMPOSITORFRAG_H_

#include <string>

namespace QueryRenderer {
namespace Impl {
namespace GLX {

struct Compositor_frag {
  static const std::string source;
};

const std::string Compositor_frag::source =
    "#version 450 core\n"
    "\n"
    "layout(location = 0) out vec4 color;\n"
    "layout(location = 1) out uint id;\n"
    "\n"
    "subroutine void compositeFunc();\n"
    "subroutine uniform compositeFunc Compositor;\n"
    "\n"
    "#define doMultiSample <doMultiSample>\n"
    "\n"
    "#if doMultiSample==1\n"
    "uniform sampler2DMSArray rgbaArraySampler;\n"
    "uniform usampler2DMSArray idArraySampler;\n"
    "#else\n"
    "uniform sampler2DArray rgbaArraySampler;\n"
    "uniform usampler2DArray idArraySampler;\n"
    "#endif\n"
    "\n"
    "uniform int rgbaArraySize;\n"
    "uniform int idArraySize;\n"
    "subroutine(compositeFunc) void compositeColor() {\n"
    "    vec4 dstColor = vec4(0,0,0,0);\n"
    "    vec4 srcColor = vec4(0,0,0,0);\n"
    "    float srcFactorRGB;\n"
    "    float dstFactorRGB;\n"
    "    float srcFactorA = 1.0;\n"
    "    float dstFactorA;\n"
    "\n"
    "    uint primitveId = 0;\n"
    "    int i = 0;\n"
    "\n"
    "    while (i < rgbaArraySize) {\n"
    "\n"
    "      // doing our own blend here to avoid mulitple texture lookups.\n"
    "      // We're doing the same blend according to:\n"
    "      // glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA)\n"
    "      // glBlendEquationsSeparate(GL_ADD, GL_ADD);\n"
    "      // This is what is beind done in the query rendering, but if that\n"
    "      // were to ever change, we'd have to change that here as well.\n"
    "      // We should look at ways of exposing all those options as subroutines.\n"
    "\n"
    "#if doMultiSample == 1\n"
    "      srcColor = texelFetch(rgbaArraySampler, ivec3(gl_FragCoord.xy, i), gl_SampleID);\n"
    "#else\n"
    "      srcColor = texelFetch(rgbaArraySampler, ivec3(gl_FragCoord.xy, i), 0);\n"
    "#endif\n"
    "\n"
    "      if (srcColor.a > 0.0) {\n"
    "        if (srcColor.a < 1.0) {\n"
    "          if (dstColor.a > 0.0) {\n"
    "            srcFactorRGB = srcColor.a;\n"
    "            dstFactorRGB = 1 - srcColor.a;\n"
    "            dstFactorA = dstFactorRGB;\n"
    "\n"
    "            dstColor = vec4(srcFactorRGB * srcColor.rgb + dstFactorRGB * dstColor.rgb, srcFactorA * srcColor.a + "
    "dstFactorA * dstColor.a);\n"
    "\n"
    "            if (dstColor.a >= 1.0) {\n"
    "              break;\n"
    "            }\n"
    "          } else {\n"
    "            dstColor = srcColor;\n"
    "          }\n"
    "        } else {\n"
    "          dstColor = srcColor;\n"
    "          break;\n"
    "        }\n"
    "      }\n"
    "\n"
    "      ++i;\n"
    "    }\n"
    "\n"
    "    if (idArraySize > 0) {\n"
    "#if doMultiSample == 1\n"
    "      primitveId = texelFetch(idArraySampler, ivec3(gl_FragCoord.xy, i), gl_SampleID).r;\n"
    "#else\n"
    "      primitveId = texelFetch(idArraySampler, ivec3(gl_FragCoord.xy, i), 0).r;\n"
    "#endif\n"
    "    }\n"
    "\n"
    "    color = dstColor;\n"
    "    id = primitveId;\n"
    "}\n"
    "\n"
    "#define maxAccumColors <maxAccumColors>\n"
    "uniform vec4 inColors[maxAccumColors];\n"
    "uniform int numAccumColors;\n"
    "\n"
    "subroutine vec4 accumFunc();\n"
    "subroutine uniform accumFunc Accumulator;\n"
    "\n"
    "layout(r32ui, binding=0) uniform readonly uimage2DArray inTxPixelCounter;\n"
    "\n"
    "subroutine(accumFunc) vec4 getMinColor() {\n"
    "    uint idx = 0;\n"
    "    uint cnt;\n"
    "    uint cnt1, cnt2;\n"
    "    int minIdx = -1;\n"
    "    uint minCnt = 10000000;\n"
    "    vec4 finalColor = vec4(0,0,0,0);\n"
    "    for (int i = 0; i < numAccumColors; i+=2) {\n"
    "        idx = i / 2;\n"
    "\n"
    "        cnt = imageLoad(inTxPixelCounter, ivec3(gl_FragCoord.xy, idx)).r;\n"
    "        cnt1 = cnt & uint(0x000000FF);\n"
    "        if (cnt1 > 0 && cnt1 < minCnt) {\n"
    "            minCnt = cnt1;\n"
    "            minIdx = i;\n"
    "        }\n"
    "        cnt2 = (cnt & uint(0x00FF0000)) >> 16;\n"
    "        if (cnt2 > 0 && cnt2 < minCnt) {\n"
    "            minCnt = cnt2;\n"
    "            minIdx = i + 1;\n"
    "        }\n"
    "    }\n"
    "    if (minIdx >= 0) {\n"
    "        finalColor = inColors[minIdx];\n"
    "    }\n"
    "    return finalColor;\n"
    "}\n"
    "\n"
    "subroutine(accumFunc) vec4 getMaxColor() {\n"
    "    uint idx = 0;\n"
    "    uint cnt;\n"
    "    uint cnt1, cnt2;\n"
    "    int maxIdx = -1;\n"
    "    uint maxCnt = 0;\n"
    "    vec4 finalColor = vec4(0,0,0,0);\n"
    "    for (int i = 0; i < numAccumColors; i+=2) {\n"
    "        idx = i / 2;\n"
    "\n"
    "        cnt = imageLoad(inTxPixelCounter, ivec3(gl_FragCoord.xy, idx)).r;\n"
    "        cnt1 = cnt & uint(0x000000FF);\n"
    "        if (cnt1 > 0 && cnt1 > maxCnt) {\n"
    "            maxCnt = cnt1;\n"
    "            maxIdx = i;\n"
    "        }\n"
    "        cnt2 = (cnt & uint(0x00FF0000)) >> 16;\n"
    "        if (cnt2 > 0 && cnt2 > maxCnt) {\n"
    "            maxCnt = cnt2;\n"
    "            maxIdx = i + 1;\n"
    "        }\n"
    "    }\n"
    "    if (maxIdx >= 0) {\n"
    "        finalColor = inColors[maxIdx];\n"
    "    }\n"
    "    return finalColor;\n"
    "}\n"
    "\n"
    "subroutine(accumFunc) vec4 getBlendColor() {\n"
    "    uint idx = 0;\n"
    "    uint cnt;\n"
    "    uint cnts[maxAccumColors + (maxAccumColors % 2)];\n"
    "    uint totalCnt = 0;\n"
    "    vec4 finalColor = vec4(0,0,0,0);\n"
    "    for (uint i = 0; i < numAccumColors; i+=2) {\n"
    "        idx = i / 2;\n"
    "\n"
    "        cnt = imageLoad(inTxPixelCounter, ivec3(gl_FragCoord.xy, idx)).r;\n"
    "        cnts[i] = cnt & uint(0x000000FF);\n"
    "        cnts[i+1] = (cnt & uint(0x00FF0000)) >> 16;\n"
    "        totalCnt += cnts[i] + cnts[i+1];\n"
    "    }\n"
    "\n"
    "    float sum = float(totalCnt);\n"
    "    for (uint i = 0; i < numAccumColors; i++) {\n"
    "        finalColor += (float(cnts[i]) / sum) * inColors[i];\n"
    "    }\n"
    "    return finalColor;\n"
    "}\n"
    "\n"
    "subroutine(compositeFunc) void compositeAccumulator() {\n"
    "    uint primitiveId = 0;\n"
    "    color = Accumulator();\n"
    "\n"
    "    if (color.a > 0) {\n"
    "        int i=0;\n"
    "        while (i < idArraySize) {\n"
    "\n"
    "#if doMultiSample == 1\n"
    "          primitiveId = texelFetch(idArraySampler, ivec3(gl_FragCoord.xy, i), gl_SampleID).r;\n"
    "#else\n"
    "          primitiveId = texelFetch(idArraySampler, ivec3(gl_FragCoord.xy, i), 0).r;\n"
    "#endif\n"
    "\n"
    "          if (primitiveId > 0) {\n"
    "              break;\n"
    "          }\n"
    "          ++i;\n"
    "        }\n"
    "    }\n"
    "    id = primitiveId;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    Compositor();\n"
    "}\n";

}  // namespace GLX
}  // namespace Impl
}  // namespace QueryRenderer

#endif  // QUERYRENDERER_GLX_COMPOSITORFRAG_H_
