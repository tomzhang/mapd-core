#ifndef ORDINALSCALETEMPLATE_VERT_H_
#define ORDINALSCALETEMPLATE_VERT_H_

#include <string>

namespace QueryRenderer {
struct OrdinalScaleTemplate_vert {
  static const std::string source;
};

const std::string OrdinalScaleTemplate_vert::source =
    "#define domainType_<name> <domainType>\n"
    "#define rangeType_<name> <rangeType>\n"
    "\n"
    "#define numDomains_<name> <numDomains>\n"
    "#define numRanges_<name> <numRanges>\n"
    "\n"
    "uniform domainType_<name> uDomains_<name>[numDomains_<name>];\n"
    "uniform domainType_<name> nullDomainVal_<name>;\n"
    "uniform rangeType_<name> uRanges_<name>[numRanges_<name>];\n"
    "uniform rangeType_<name> nullRangeVal_<name>;\n"
    "uniform rangeType_<name> uDefault_<name>;\n"
    "\n"
    "subroutine bool IsNullValSubroutine_<name>(in domainType_<name>);\n"
    "subroutine uniform IsNullValSubroutine_<name> isNullValFunc_<name>;\n"
    "subroutine(IsNullValSubroutine_<name>) bool isNullValPassThru_<name>(in domainType_<name> val) {\n"
    "    return false;\n"
    "}\n"
    "\n"
    "subroutine(IsNullValSubroutine_<name>) bool isNullVal_<name>(in domainType_<name> val) {\n"
    "    if (val == nullDomainVal_<name>) {\n"
    "        return true;\n"
    "    }\n"
    "    return false;\n"
    "}\n"
    "\n"
    "#define doAccum_OrdinalScale_<name> <doAccum>\n"
    "\n"
    "#if doAccum_OrdinalScale_<name> == 1\n"
    "flat out int accumIdx;   // the ordinal domain index for accumulations\n"
    "#endif\n"
    "\n"
    "rangeType_<name> getOrdinalScale_<name>(in domainType_<name> category) {\n"
    "    int idx = -1;\n"
    "    rangeType_<name> val = uDefault_<name>;\n"
    "    if (isNullValFunc_<name>(category)) {\n"
    "        idx = numDomains_<name> + 1;\n"
    "        val = nullRangeVal_<name>;\n"
    "    } else {\n"
    "    #if numDomains_<name> == 1 || numRanges_<name> == 1\n"
    "        if (category == uDomains_<name>[0]) {\n"
    "            idx = 0;\n"
    "            val = uRanges_<name>[0];\n"
    "        }\n"
    "    #else\n"
    "        // performs a binary search so domain needs to be\n"
    "        // properly sorted.\n"
    "        int startIdx = 0;\n"
    "        int endIdx = numDomains_<name>-1;\n"
    "        int midIdx = 0;\n"
    "\n"
    "        domainType_<name> midVal = domainType_<name>(0);\n"
    "\n"
    "        if (category == uDomains_<name>[startIdx]) {\n"
    "            idx = startIdx;\n"
    "        } else if (category == uDomains_<name>[endIdx]) {\n"
    "            idx = endIdx;\n"
    "        } else if (category < uDomains_<name>[startIdx] || category > uDomains_<name>[endIdx]) {\n"
    "            idx = -1;\n"
    "        } else {\n"
    "            while (true) {\n"
    "                midIdx = startIdx + ((endIdx - startIdx) / 2);\n"
    "                if (midIdx == startIdx) {\n"
    "                    break;\n"
    "                } else {\n"
    "                    midVal = uDomains_<name>[midIdx];\n"
    "                    if (category == midVal) {\n"
    "                        idx = midIdx;\n"
    "                        break;\n"
    "                    } else if (category > midVal) {\n"
    "                        startIdx = midIdx;\n"
    "                    } else if (category < midVal) {  // for some reason, just an else doesn't work here ????\n"
    "                        endIdx = midIdx;\n"
    "                    }\n"
    "                }\n"
    "            }\n"
    "        }\n"
    "\n"
    "        if (idx >= 0) {\n"
    "            idx = idx % numRanges_<name>;\n"
    "            val = uRanges_<name>[idx];\n"
    "        }\n"
    "\n"
    "    #endif\n"
    "    }\n"
    "\n"
    "    #if doAccum_OrdinalScale_<name> == 1\n"
    "        if (idx < 0) {\n"
    "            idx = numDomains_<name>;\n"
    "        }\n"
    "        accumIdx = idx;\n"
    "    #endif\n"
    "\n"
    "    return val;\n"
    "}\n";
}  // namespace QueryRenderer

#endif  // ORDINALSCALETEMPLATE_VERT_H_
