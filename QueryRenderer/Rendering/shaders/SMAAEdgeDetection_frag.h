/**
 * Copyright (C) 2013 Jorge Jimenez (jorge@iryoku.com)
 * Copyright (C) 2013 Jose I. Echevarria (joseignacioechevarria@gmail.com)
 * Copyright (C) 2013 Belen Masia (bmasia@unizar.es)
 * Copyright (C) 2013 Fernando Navarro (fernandn@microsoft.com)
 * Copyright (C) 2013 Diego Gutierrez (diegog@unizar.es)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to
 * do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software. As clarification, there
 * is no requirement that the copyright notice and permission be included in
 * binary distributions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef SMAAEDGEDETECTION_FRAG_H_
#define SMAAEDGEDETECTION_FRAG_H_

#include <string>

namespace QueryRenderer {
struct SMAAEdgeDetection_frag {
  static const std::string source;
};

const std::string SMAAEdgeDetection_frag::source =
    "#version 450 core\n"
    "\n"
    "/**\n"
    " * Edge Detection Fragment Shader\n"
    " */\n"
    "\n"
    "//-----------------------------------------------------------------------------\n"
    "// SMAA Presets\n"
    "\n"
    "/**\n"
    " * Note that if you use one of these presets, the following configuration\n"
    " * macros will be ignored if set in the \" Configurable Defines \" section.\n"
    " */\n"
    "\n"
    "#if defined(SMAA_PRESET_LOW)\n"
    "#define SMAA_THRESHOLD 0.15\n"
    "#elif defined(SMAA_PRESET_MEDIUM)\n"
    "#define SMAA_THRESHOLD 0.1\n"
    "#elif defined(SMAA_PRESET_HIGH)\n"
    "#define SMAA_THRESHOLD 0.1\n"
    "#elif defined(SMAA_PRESET_ULTRA)\n"
    "#define SMAA_THRESHOLD 0.05\n"
    "#endif\n"
    "\n"
    "/**\n"
    " * If there is an neighbor edge that has SMAA_LOCAL_CONTRAST_FACTOR times\n"
    " * bigger contrast than current edge, current edge will be discarded.\n"
    " *\n"
    " * This allows to eliminate spurious crossing edges, and is based on the fact\n"
    " * that, if there is too much contrast in a direction, that will hide\n"
    " * perceptually contrast in the other neighbors.\n"
    " */\n"
    "#ifndef SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR\n"
    "#define SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR 2.0\n"
    "#endif\n"
    "\n"
    "uniform vec4 SMAA_RT_METRICS;\n"
    "uniform vec4 FULL_SMAA_RT_METRICS;\n"
    "\n"
    "/**\n"
    " * Gathers current pixel, and the top-left neighbors.\n"
    " */\n"
    "vec3 SMAAGatherNeighbours(vec2 texcoord,\n"
    "                          vec4 offset[3],\n"
    "                          sampler2D tex) {\n"
    "    return textureGather(tex, texcoord + FULL_SMAA_RT_METRICS.xy * vec2(-0.5, -0.5)).grb;\n"
    "}\n"
    "\n"
    "#ifdef SMAA_PREDICATION\n"
    "\n"
    "/**\n"
    " * Threshold to be used in the additional predication buffer.\n"
    " *\n"
    " * Range: depends on the input, so you'll have to find the magic number that\n"
    " * works for you.\n"
    " */\n"
    "#ifndef SMAA_PREDICATION_THRESHOLD\n"
    "#define SMAA_PREDICATION_THRESHOLD 0.01\n"
    "#endif\n"
    "\n"
    "/**\n"
    " * How much to scale the global threshold used for luma or color edge\n"
    " * detection when using predication.\n"
    " *\n"
    " * Range: [1, 5]\n"
    " */\n"
    "#ifndef SMAA_PREDICATION_SCALE\n"
    "#define SMAA_PREDICATION_SCALE 2.0\n"
    "#endif\n"
    "\n"
    "/**\n"
    " * How much to locally decrease the threshold.\n"
    " *\n"
    " * Range: [0, 1]\n"
    " */\n"
    "#ifndef SMAA_PREDICATION_STRENGTH\n"
    "#define SMAA_PREDICATION_STRENGTH 0.4\n"
    "#endif\n"
    "\n"
    "uniform sampler2D predicationTex;\n"
    "\n"
    "/**\n"
    " * Adjusts the threshold by means of predication.\n"
    " */\n"
    "vec2 SMAACalculatePredicatedThreshold(vec2 texcoord,\n"
    "                                      vec4 offset[3],\n"
    "                                      sampler2D predicationTex) {\n"
    "    vec3 neighbours = SMAAGatherNeighbours(texcoord, offset, predicationTex);\n"
    "    vec2 delta = abs(neighbours.xx - neighbours.yz);\n"
    "    vec2 edges = step(SMAA_PREDICATION_THRESHOLD, delta);\n"
    "    return SMAA_PREDICATION_SCALE * SMAA_THRESHOLD * (1.0 - SMAA_PREDICATION_STRENGTH * edges);\n"
    "}\n"
    "#endif // SMAA_PREDICATION\n"
    "\n"
    "\n"
    "subroutine vec2 EdgeDetectionFunc(vec2 texcoord,\n"
    "                                  vec4 offset[3],\n"
    "                                  sampler2D colorTex\n"
    "                                  #ifdef SMAA_PREDICATION\n"
    "                                  , sampler2D predicationTex\n"
    "                                  #endif\n"
    "                                 );\n"
    "subroutine uniform EdgeDetectionFunc detectEdges;\n"
    " /**\n"
    " * Luma Edge Detection\n"
    " *\n"
    " * IMPORTANT NOTICE: luma edge detection requires gamma-corrected colors, and\n"
    " * thus 'colorTex' should be a non-sRGB texture.\n"
    " */\n"
    "subroutine(EdgeDetectionFunc) vec2 SMAALumaEdgeDetection(vec2 texcoord,\n"
    "                                                         vec4 offset[3],\n"
    "                                                         sampler2D colorTex\n"
    "                                                         #ifdef SMAA_PREDICATION\n"
    "                                                         , sampler2D predicationTex\n"
    "                                                         #endif\n"
    "                                                        ) {\n"
    "    // Calculate the threshold:\n"
    "    #ifdef SMAA_PREDICATION\n"
    "    vec2 threshold = SMAACalculatePredicatedThreshold(texcoord, offset, predicationTex);\n"
    "    #else\n"
    "    vec2 threshold = vec2(SMAA_THRESHOLD, SMAA_THRESHOLD);\n"
    "    #endif\n"
    "\n"
    "    // Calculate lumas:\n"
    "    vec3 weights = vec3(0.2126, 0.7152, 0.0722);\n"
    // "    vec4 C = texture(colorTex, texcoord);\n"
    "    vec4 C = texelFetch(colorTex, ivec2(gl_FragCoord.xy), 0);\n"
    "    float L = dot(C.rgb, weights);\n"
    "\n"
    // "    vec4 Cleft = texture(colorTex, offset[0].xy);\n"
    "    vec4 Cleft = texelFetch(colorTex, ivec2(offset[0].xy), 0);\n"
    "    float Lleft = dot(Cleft.rgb, weights);\n"
    "\n"
    // "    vec4 Ctop = texture(colorTex, offset[0].zw);\n"
    "    vec4 Ctop = texelFetch(colorTex, ivec2(offset[0].zw), 0);\n"
    "    float Ltop  = dot(Ctop.rgb, weights);\n"
    "\n"
    "    // We do the usual threshold:\n"
    "    vec4 delta;\n"
    "    delta.xy = abs(L - vec2(Lleft, Ltop));\n"
    "    vec2 edges = step(threshold, delta.xy);\n"
    "\n"
    "    // Then discard if there is no edge:\n"
    "    if (dot(edges, vec2(1.0, 1.0)) == 0.0) {\n"
    "        // check alpha differences before discarding\n"
    "        // An edge can be determined via alpha when there's\n"
    "        // a pixel with some alpha next to a pixel with no\n"
    "        // alpha\n"
    "        float alpha = step(1e-5, C.a);\n"
    "        float alphaL = step(1e-5, Cleft.a);\n"
    "        float alphaT = step(1e-5, Ctop.a);\n"
    "        delta.x = abs(alphaL - alpha);\n"
    "        delta.y = abs(alphaT - alpha);\n"
    "        if (delta.x + delta.y == 0.0) {\n"
    "            discard;\n"
    "        }\n"
    "        edges = delta.xy;\n"
    "    }\n"
    "\n"
    "    // Calculate right and bottom deltas:\n"
    // "    float Lright = dot(texture(colorTex, offset[1].xy).rgb, weights);\n"
    "    float Lright = dot(texelFetch(colorTex, ivec2(offset[1].xy), 0).rgb, weights);\n"
    // "    float Lbottom  = dot(texture(colorTex, offset[1].zw).rgb, weights);\n"
    "    float Lbottom  = dot(texelFetch(colorTex, ivec2(offset[1].zw), 0).rgb, weights);\n"
    "    delta.zw = abs(L - vec2(Lright, Lbottom));\n"
    "\n"
    "    // Calculate the maximum delta in the direct neighborhood:\n"
    "    vec2 maxDelta = max(delta.xy, delta.zw);\n"
    "\n"
    "    // Calculate left-left and top-top deltas:\n"
    // "    float Lleftleft = dot(texture(colorTex, offset[2].xy).rgb, weights);\n"
    "    float Lleftleft = dot(texelFetch(colorTex, ivec2(offset[2].xy), 0).rgb, weights);\n"
    // "    float Ltoptop = dot(texture(colorTex, offset[2].zw).rgb, weights);\n"
    "    float Ltoptop = dot(texelFetch(colorTex, ivec2(offset[2].zw), 0).rgb, weights);\n"
    "    delta.zw = abs(vec2(Lleft, Ltop) - vec2(Lleftleft, Ltoptop));\n"
    "\n"
    "    // Calculate the final maximum delta:\n"
    "    maxDelta = max(maxDelta.xy, delta.zw);\n"
    "    float finalDelta = max(maxDelta.x, maxDelta.y);\n"
    "\n"
    "    // Local contrast adaptation:\n"
    "    edges.xy *= step(finalDelta, SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);\n"
    "\n"
    "    return edges;\n"
    "}\n"
    "\n"
    "/**\n"
    " * Color Edge Detection\n"
    " *\n"
    " * IMPORTANT NOTICE: color edge detection requires gamma-corrected colors, and\n"
    " * thus 'colorTex' should be a non-sRGB texture.\n"
    " */\n"
    "subroutine(EdgeDetectionFunc) vec2 SMAAColorEdgeDetection(vec2 texcoord,\n"
    "                                                          vec4 offset[3],\n"
    "                                                          sampler2D colorTex\n"
    "                                                          #ifdef SMAA_PREDICATION\n"
    "                                                          , sampler2D predicationTex\n"
    "                                                          #endif\n"
    "                                                         ) {\n"
    "    // Calculate the threshold:\n"
    "    #ifdef SMAA_PREDICATION\n"
    "    vec2 threshold = SMAACalculatePredicatedThreshold(texcoord, offset, predicationTex);\n"
    "    #else\n"
    "    vec2 threshold = vec2(SMAA_THRESHOLD, SMAA_THRESHOLD);\n"
    "    #endif\n"
    "\n"
    "    // Calculate color deltas:\n"
    "    vec4 delta;\n"
    // "    vec4 C = texture(colorTex, texcoord);\n"
    "    vec4 C = texelFetch(colorTex, ivec2(gl_FragCoord.xy), 0);\n"
    "    // an edge is only detected using alpha when\n"
    "    // we go from some alpha to no alpha -- so do a step\n"
    "    // on the alpha channel"
    "    C.a = step(1e-5, C.a);\n"
    "\n"
    // "    vec4 Cleft = texture(colorTex, offset[0].xy);\n"
    "    vec4 Cleft = texelFetch(colorTex, ivec2(offset[0].xy), 0);\n"
    "    Cleft.a = step(1e-5, Cleft.a);\n"
    "    vec4 t = abs(C - Cleft);\n"
    "    delta.x = max(max(t.r, t.g), max(t.b, t.a));\n"
    "\n"
    // "    vec4 Ctop  = texture(colorTex, offset[0].zw);\n"
    "    vec4 Ctop  = texelFetch(colorTex, ivec2(offset[0].zw), 0);\n"
    "    Ctop.a = step(1e-5, Ctop.a);\n"
    "    t = abs(C - Ctop);\n"
    "    delta.y = max(max(t.r, t.g), max(t.b, t.a));\n"
    "\n"
    "    // We do the usual threshold:\n"
    "    vec2 edges = step(threshold, delta.xy);\n"
    "\n"
    "    // Then discard if there is no edge:\n"
    "    if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n"
    "        discard;\n"
    "\n"
    "    // Calculate right and bottom deltas:\n"
    // "    vec4 Cright = texture(colorTex, offset[1].xy);\n"
    "    vec4 Cright = texelFetch(colorTex, ivec2(offset[1].xy), 0);\n"
    "    Cright.a = step(1e-5, Cright.a);\n"
    "    t = abs(C - Cright);\n"
    "    delta.z = max(max(t.r, t.g), max(t.b, t.a));\n"
    "\n"
    // "    vec4 Cbottom  = texture(colorTex, offset[1].zw);\n"
    "    vec4 Cbottom  = texelFetch(colorTex, ivec2(offset[1].zw), 0);\n"
    "    Cbottom.a = step(1e-5, Cbottom.a);\n"
    "    t = abs(C - Cbottom);\n"
    "    delta.w = max(max(t.r, t.g), max(t.b, t.a));\n"
    "\n"
    "    // Calculate the maximum delta in the direct neighborhood:\n"
    "    vec2 maxDelta = max(delta.xy, delta.zw);\n"
    "\n"
    "    // Calculate left-left and top-top deltas:\n"
    // "    vec4 Cleftleft  = texture(colorTex, offset[2].xy);\n"
    "    vec4 Cleftleft  = texelFetch(colorTex, ivec2(offset[2].xy), 0);\n"
    "    Cleftleft.a = step(1e-5, Cleftleft.a);\n"
    "    t = abs(C - Cleftleft);\n"
    "    delta.z = max(max(t.r, t.g), max(t.b, t.a));\n"
    "\n"
    // "    vec4 Ctoptop = texture(colorTex, offset[2].zw);\n"
    "    vec4 Ctoptop = texelFetch(colorTex, ivec2(offset[2].zw), 0);\n"
    "    Ctoptop.a = step(1e-5, Ctoptop.a);\n"
    "    t = abs(C - Ctoptop);\n"
    "    delta.w = max(max(t.r, t.g), max(t.b, t.a));\n"
    "\n"
    "    // Calculate the final maximum delta:\n"
    "    maxDelta = max(maxDelta.xy, delta.zw);\n"
    "    float finalDelta = max(maxDelta.x, maxDelta.y);\n"
    "\n"
    "    // Local contrast adaptation:\n"
    "    edges.xy *= step(finalDelta, SMAA_LOCAL_CONTRAST_ADAPTATION_FACTOR * delta.xy);\n"
    "\n"
    "    return edges;\n"
    "}\n"
    "\n"
    "/**\n"
    " * SMAA_DEPTH_THRESHOLD specifies the threshold for depth edge detection.\n"
    " *\n"
    " * Range: depends on the depth range of the scene.\n"
    " */\n"
    "#ifndef SMAA_DEPTH_THRESHOLD\n"
    "#define SMAA_DEPTH_THRESHOLD (0.1 * SMAA_THRESHOLD)\n"
    "#endif\n"
    "\n"
    "/**\n"
    " * Depth Edge Detection\n"
    " */\n"
    "subroutine(EdgeDetectionFunc) vec2 SMAADepthEdgeDetection(vec2 texcoord,\n"
    "                                                          vec4 offset[3],\n"
    "                                                          sampler2D depthTex\n"
    "                                                          #ifdef SMAA_PREDICATION\n"
    "                                                          , sampler2D predicationTex\n"
    "                                                          #endif\n"
    "                                                         ) {\n"
    // TODO(croot): make depth edge detection work with texel fetches
    "    vec3 neighbours = SMAAGatherNeighbours(texcoord, offset, depthTex);\n"
    "    vec2 delta = abs(neighbours.xx - vec2(neighbours.y, neighbours.z));\n"
    "    vec2 edges = step(SMAA_DEPTH_THRESHOLD, delta);\n"
    "\n"
    "    if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n"
    "        discard;\n"
    "\n"
    "    return edges;\n"
    "}\n"
    "\n"
    "void SMAAEdgeDetectionCalcOffsets(vec2 texcoord,\n"
    "                                  out vec4 offset[3]) {\n"
    // "    offset[0] = fma(FULL_SMAA_RT_METRICS.xyxy, vec4(-1.0, 0.0, 0.0,  1.0), texcoord.xyxy);\n"
    // "    offset[1] = fma(FULL_SMAA_RT_METRICS.xyxy, vec4( 1.0, 0.0, 0.0, -1.0), texcoord.xyxy);\n"
    // "    offset[2] = fma(FULL_SMAA_RT_METRICS.xyxy, vec4(-2.0, 0.0, 0.0,  2.0), texcoord.xyxy);\n"
    "    offset[0] = gl_FragCoord.xyxy + vec4(-1.0, 0.0, 0.0, 1.0);\n"
    "    offset[0].x = max(offset[0].x, 0.0);\n"
    "    offset[0].w = min(offset[0].w, SMAA_RT_METRICS.w - 1);\n"
    "    offset[1] = gl_FragCoord.xyxy + vec4(1.0, 0.0, 0.0, -1.0);\n"
    "    offset[1].x = min(offset[1].x, SMAA_RT_METRICS.z - 1);\n"
    "    offset[1].w = max(offset[1].w, 0.0);\n"
    "    offset[2] = gl_FragCoord.xyxy + vec4(-2.0, 0.0, 0.0, 2.0);\n"
    "    offset[2].x = max(offset[2].x, 0.0);\n"
    "    offset[2].w = min(offset[2].w, SMAA_RT_METRICS.w - 1);\n"
    "}\n"
    "\n"
    "layout(location = 0) out vec4 color;\n"
    "\n"
    "uniform sampler2D colorTex;\n"
    "in vec2 fTexCoord;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "    vec4 offsets[3];\n"
    "    offsets[0] = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "    offsets[1] = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "    offsets[2] = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "    SMAAEdgeDetectionCalcOffsets(fTexCoord, offsets);\n"
    "\n"
    "    color = vec4(detectEdges(fTexCoord,\n"
    "                             offsets,\n"
    "                             colorTex\n"
    "                             #ifdef SMAA_PREDICATION\n"
    "                             , predicationTex\n"
    "                             #endif\n"
    "                            ), 0.0, 0.0);\n"
    "}\n";

}  // namespace QueryRenderer

#endif  // SMAAEDGEDETECTION_FRAG_H_
