#ifndef POINTTEMPLATE_VERT_H_
#define POINTTEMPLATE_VERT_H_

#include <string>

namespace QueryRenderer {
struct PointTemplate_Vert {
  static const std::string source;
};

const std::string PointTemplate_Vert::source =
    "// VERTEX SHADER\n"
    "\n"
    "#version 450 core\n"
    "\n"
    "#define useUx <useUx>\n"
    "#define inTx <inTxType>\n"
    "#define inTxEnum <inTxEnum>\n"
    "#define outTx <outTxType>\n"
    "#define outTxEnum <outTxEnum>\n"
    "\n"
    "#define useUy <useUy>\n"
    "#define inTy <inTyType>\n"
    "#define inTyEnum <inTyEnum>\n"
    "#define outTy <outTyType>\n"
    "#define outTyEnum <outTyEnum>\n"
    "\n"
    "// #define useUz <useUz>\n"
    "// #define inTz float\n"
    "// #define outTz float\n"
    "\n"
    "#define useUsize <useUsize>\n"
    "#define inTsize <inTsizeType>\n"
    "#define inTsizeEnum <inTsizeEnum>\n"
    "#define outTsize <outTsizeType>\n"
    "#define outTsizeEnum <outTsizeEnum>\n"
    "\n"
    "#define useUfillColor <useUfillColor>\n"
    "#define inTfillColor <inTfillColorType>\n"
    "#define inTfillColorEnum <inTfillColorEnum>\n"
    "#define outTfillColor <outTfillColorType>\n"
    "#define outTfillColorEnum <outTfillColorEnum>\n"
    "\n"
    "#define useUid <useUid>\n"
    "#define inTid <inTidType>\n"
    "#define inTidEnum <inTidEnum>\n"
    "\n"
    "#define useKey <useKey>\n"
    "#define useUkey <useUkey>\n"
    "#define inTkey <inTkeyType>\n"
    "\n"
    "#if EXT_GL_NV_gpu_shader5 == 1 || EXT_GL_AMD_gpu_shader_int64 == 1\n"
    "#define EXP_TYPE uint64_t\n"
    "#else\n"
    "#define EXP_TYPE uint\n"
    "#endif\n"
    "\n"
    "#if useUx == 1\n"
    "uniform inTx x;\n"
    "#else\n"
    "in inTx x;\n"
    "#endif\n"
    "uniform EXP_TYPE x_ExpScale;\n"
    "\n"
    "#if useUy == 1\n"
    "uniform inTy y;\n"
    "#else\n"
    "in inTy y;\n"
    "#endif\n"
    "uniform EXP_TYPE y_ExpScale;\n"
    "\n"
    "// #if useUz == 1\n"
    "// uniform inTz z;\n"
    "// #else\n"
    "// in inTz z;\n"
    "// #endif\n"
    "// uniform EXP_TYPE z_ExpScale;\n"
    "\n"
    "#if useUsize == 1\n"
    "uniform inTsize size;\n"
    "#else\n"
    "in inTsize size;\n"
    "#endif\n"
    "uniform EXP_TYPE size_ExpScale;\n"
    "\n"
    "#if useUfillColor == 1\n"
    "uniform inTfillColor fillColor;\n"
    "#else\n"
    "in inTfillColor fillColor;\n"
    "#endif\n"
    "uniform EXP_TYPE fillColor_ExpScale;\n"
    "\n"
    "#if useUid == 1\n"
    "uniform inTid id;\n"
    "#else\n"
    "in inTid id;\n"
    "#endif\n"
    "\n"
    "#if useKey == 1\n"
    "#if useUkey == 1\n"
    "uniform inTkey key;\n"
    "#else\n"
    "in inTkey key;\n"
    "#endif\n"
    "uniform inTkey invalidKey;\n"
    "#endif\n"
    "\n"
    // TODO(croot): create general conversion utilities somewhere
    // that can be added via #include
    "double convertDecimalToDouble(in int64_t val, in EXP_TYPE scale) {\n"
    "    return double(val) / double(scale);\n"
    "}\n"
    "\n"
    "outTx getx(in inTx x) {\n"
    "#if inTxEnum == outTxEnum\n"
    "  return x;\n"
    "#else\n"
    "  return outTx(x);\n"
    "#endif\n"
    "}\n"
    "\n"
    "outTy gety(in inTy y) {\n"
    "#if inTyEnum == outTyEnum\n"
    "  return y;\n"
    "#else\n"
    "  return outTy(y);\n"
    "#endif\n"
    "}\n"
    "\n"
    "// outTz getz(in inTz z) {\n"
    "//     return z;\n"
    "// }\n"
    "\n"
    "outTsize getsize(in inTsize size) {\n"
    "#if inTsizeEnum == outTsizeEnum\n"
    "  return size;\n"
    "#else\n"
    "  return outTsize(size);\n"
    "#endif\n"
    "}\n"
    "\n"
    // TODO(croot): create a set of color utility functions that
    // can be added #include -- need to create the utility functions
    // and create an ability to #include utilities
    "subroutine vec4 TransformColorToRGBSubroutine(in vec4);\n"
    "subroutine uniform TransformColorToRGBSubroutine transformColorToRGB;\n"
    "subroutine(TransformColorToRGBSubroutine) vec4 transformRGBtoRGB(in vec4 incolorRGB) {\n"
    "    return incolorRGB;\n"
    "}\n"
    "\n"
    "subroutine(TransformColorToRGBSubroutine) vec4 transformHSLtoRGB(in vec4 incolorHSL) {\n"
    "    float h = mod(incolorHSL[0], 360.0), s = incolorHSL[1], l = incolorHSL[2];\n"
    "    if (h < 0) {\n"
    "        h += 360.0;\n"
    "    }\n"
    "    float r = 0, g = 0, b = 0;\n"
    "    float C = s * (1 - abs(2 * l - 1));\n"
    "    float X = C * (1 - abs(mod(h / 60.0, 2.0) - 1));\n"
    "    float m = l - C / 2.0;\n"
    "\n"
    "    int huecat = int(h / 60.0);\n"
    "    if (huecat == 0) {\n"
    "        r = C;\n"
    "        g = X;\n"
    "    } else if (huecat == 1) {\n"
    "        r = X;\n"
    "        g = C;\n"
    "    } else if (huecat == 2) {\n"
    "        g = C;\n"
    "        b = X;\n"
    "    } else if (huecat == 3) {\n"
    "        g = X;\n"
    "        b = C;\n"
    "    } else if (huecat == 4) {\n"
    "        r = X;\n"
    "        b = C;\n"
    "    } else {\n"
    "        r = C;\n"
    "        b = X;\n"
    "    }\n"
    "\n"
    "    return vec4(r + m, g + m, b + m, incolorHSL[3]);\n"
    "}\n"
    "\n"
    "const float Kn = 18,\n"
    "              Xn = 0.950470,  // D65 standard referent\n"
    "              Yn = 1, Zn = 1.088830, \n"
    "              t0 = 4.0 / 29.0, t1 = 6.0 / 29.0,\n"
    "              t2 = 3.0 * pow(6.0 / 29.0, 2.0),\n"
    "              t3 = pow(6.0 / 29.0, 3.0);\n"
    "\n"
    "float xyz2rgb(in float xyzchannel) {\n"
    "    return (xyzchannel <= 0.0031308 ? 12.92 * xyzchannel : 1.055 * pow(xyzchannel, 1 / 2.4) - 0.055);\n"
    "}\n"
    "\n"
    "float lab2xyz(in float labchannel) {\n"
    "    return (labchannel > t1 ? labchannel * labchannel * labchannel : t2 * (labchannel - t0));\n"
    "}\n"
    "\n"
    "subroutine(TransformColorToRGBSubroutine) vec4 transformLABtoRGB(in vec4 incolorLAB) {\n"
    "    float y = (incolorLAB[0] + 16.0) / 116.0, x = isnan(incolorLAB[1]) ? y : y + incolorLAB[1] / 500.0,\n"
    "          z = isnan(incolorLAB[2]) ? y : y - incolorLAB[2] / 200.0;\n"
    "    y = Yn * lab2xyz(y);\n"
    "    x = Xn * lab2xyz(x);\n"
    "    z = Zn * lab2xyz(z);\n"
    "    return vec4(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z),  // D65 -> sRGB\n"
    "                xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n"
    "                xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z),\n"
    "                incolorLAB.a);\n"
    "}\n"
    "\n"
    "subroutine(TransformColorToRGBSubroutine) vec4 transformHCLtoRGB(in vec4 incolorHCL) {\n"
    "    float h = radians(incolorHCL[0]);\n"
    "    return transformLABtoRGB(vec4(incolorHCL[2], cos(h) * incolorHCL[1], sin(h) * incolorHCL[1], "
    "incolorHCL[3]));\n"
    "}\n"
    "\n"
    "subroutine vec4 UnpackColorSubroutine(in uint);\n"
    "subroutine uniform UnpackColorSubroutine unpackColor;\n"
    "subroutine(UnpackColorSubroutine) vec4 unpackRGBAColor(in uint incolorRGB) {\n"
    "    vec4 color;\n"
    "    color.r = float((incolorRGB >> 24) & 0xFF) / 255.0;\n"
    "    color.g = float((incolorRGB >> 16) & 0xFF) / 255.0;\n"
    "    color.b = float((incolorRGB >> 8) & 0xFF) / 255.0;\n"
    "    color.a = float(incolorRGB & 0xFF) / 255.0;\n"
    "    return color;\n"
    "}\n"
    "\n"
    "subroutine(UnpackColorSubroutine) vec4 unpackLABColor(in uint incolorLAB) {\n"
    "    vec4 color;\n"
    "    color.r = 100.0 * (float((incolorLAB >> 24) & 0xFF) / 255.0);\n"
    "    color.g = 256.0 * (float((incolorLAB >> 16) & 0xFF) / 255.0) - 128.0;\n"
    "    color.b = 256.0 * (float((incolorLAB >> 8) & 0xFF) / 255.0) - 128.0;\n"
    "    color.a = float(incolorLAB & 0xFF) / 255.0;\n"
    "    return color;\n"
    "}\n"
    "\n"
    "outTfillColor getfillColor(in inTfillColor fillColor) {\n"
    "#if (inTfillColorEnum == INT || inTfillColorEnum == UNSIGNED_INT) && outTfillColorEnum == FLOAT_VEC4\n"
    "    return unpackColor(fillColor);\n"
    "#elif inTfillColorEnum == INT64_NV || inTfillColorEnum == UNSIGNED_INT64_NV\n"
    "    return unpackColor(uint(fillColor));\n"
    "#else\n"
    "    return fillColor;\n"
    "#endif\n"
    "}\n"
    "\n"
    "////////////////////////////////////////////////////////////////\n"
    "/**\n"
    "* Non-interpolated shader outputs.\n"
    "*/\n"
    "flat out inTid fPrimitiveId;  // the id of the primitive\n"
    "flat out vec4 fColor;        // the output color of the primitive\n"
    "flat out float fPointSize;   // the point size of the vertex\n"
    "\n"
    "void main() {\n"
    "#if useKey == 1\n"
    "if (key != invalidKey) {\n"
    "gl_Position = vec4(float(getx(x)), float(gety(y)), 0.5, 1.0);\n"
    "float sz = float(getsize(size));\n"
    "fPointSize = sz;\n"
    "gl_PointSize = sz;\n"
    "\n"
    "fColor = transformColorToRGB(getfillColor(fillColor));\n"
    "} else {\n"
    "gl_Position = vec4(0, 0, 0, 0);\n"
    "fPointSize = 0.0;\n"
    "gl_PointSize = 0.0;\n"
    "fColor = vec4(0, 0, 0, 0);\n"
    "}\n"
    "#else\n"
    "gl_Position = vec4(float(getx(x)), float(gety(y)), 0.5, 1.0);\n"
    "float sz = float(getsize(size));\n"
    "fPointSize = sz;\n"
    "gl_PointSize = sz;\n"
    "\n"
    "fColor = transformColorToRGB(getfillColor(fillColor));\n"
    "#endif\n"
    "\n"
    "// ids from queries go from 0 to numrows-1, but since we're storing\n"
    "// the ids as unsigned ints, and there isn't a way to specify the\n"
    "// clear value for secondary buffers, we need to account for that\n"
    "// offset here\n"
    "fPrimitiveId = id + 1;\n"
    "}\n";

}  // namespace QueryRenderer

#endif  // POINTTEMPLATE_VERT_H_
