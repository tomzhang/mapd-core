#ifndef QUANTITATIVESCALETEMPLATE_VERT_H_
#define QUANTITATIVESCALETEMPLATE_VERT_H_

#include <string>
#include <Rendering/Renderer/GL/TypeGL.h>

namespace QueryRenderer {
struct QuantitativeScaleTemplate_vert {
  static const std::string source;
};

// Before using this shader source, it should be prepended by
// the string that is returned from
// ::Rendering::GL::BaseTypeGL::getTypeDefinesMacroForShader()
// That can't be done here as GL hasn't been initialized yet
// and it can only be used after GL is initialized.
const std::string QuantitativeScaleTemplate_vert::source =
    "#define domainType_<name> <domainType>\n"
    "#define domainTypeEnum_<name> <domainTypeEnum>\n"
    "#define rangeType_<name> <rangeType>\n"
    "#define rangeTypeEnum_<name> <rangeTypeEnum>\n"
    "\n"
    "#define numDomains_<name> <numDomains>\n"
    "#define numRanges_<name> <numRanges>\n"
    "#define useClamp_<name> <useClamp>\n"
    "\n"
    "uniform domainType_<name> uDomains_<name>[numDomains_<name>];\n"
    "uniform domainType_<name> nullDomainVal_<name>;\n"
    "uniform rangeType_<name> uRanges_<name>[numRanges_<name>];\n"
    "uniform rangeType_<name> nullRangeVal_<name>;\n"
    "\n"
    "subroutine bool IsNullValSubroutine_<name>(in domainType_<name>);\n"
    "subroutine uniform IsNullValSubroutine_<name> isNullValFunc_<name>;\n"
    "subroutine(IsNullValSubroutine_<name>) bool isNullValPassThru_<name>(in domainType_<name> val) {\n"
    "    return false;\n"
    "}\n"
    "\n"
    "subroutine(IsNullValSubroutine_<name>) bool isNullVal_<name>(in domainType_<name> val) {\n"
    "    if (val == nullDomainVal_<name>) {\n"
    "        return true;\n"
    "    }\n"
    "    return false;\n"
    "}\n"
    "\n"
    "#define doAccum_QuantitativeScale_<name> <doAccum>\n"
    "\n"
    "#if doAccum_QuantitativeScale_<name> == 1\n"
    "flat out int accumIdx;   // the ordinal domain index for accumulations\n"
    "#endif\n"
    "\n"
    "subroutine domainType_<name> QuantTransformFunc_<name>(in domainType_<name>);\n"
    "subroutine uniform QuantTransformFunc_<name> quantTransform_<name>;\n"
    "\n"
    "subroutine(QuantTransformFunc_<name>) domainType_<name> passThruTransform_<name>(in domainType_<name> val) {\n"
    "    return val;\n"
    "}\n"
    "\n"
    "subroutine(QuantTransformFunc_<name>) domainType_<name> logTransform_<name>(in domainType_<name> val) {\n"
    "    return domainType_<name>(log(float(val)));\n"
    "}\n"
    "\n"
    "uniform float uExponent_<name>;\n"
    "subroutine(QuantTransformFunc_<name>) domainType_<name> powTransform_<name>(in domainType_<name> val) {\n"
    "    return domainType_<name>(pow(float(val), uExponent_<name>));\n"
    "}\n"
    "\n"
    "subroutine(QuantTransformFunc_<name>) domainType_<name> sqrtTransform_<name>(in domainType_<name> val) {\n"
    "#if domainTypeEnum_<name> == DOUBLE\n"
    "    return sqrt(val);\n"
    "#elif domainTypeEnum_<name> == UNSIGNED_INT64_NV || domainTypeEnum_<name> == INT64_NV\n"
    "    return domainType_<name>(sqrt(double(val)));\n"
    "#else\n"
    "    return domainType_<name>(sqrt(float(val)));\n"
    "#endif\n"
    "}\n"
    "\n"
    "subroutine rangeType_<name> QuantInterpFunc_<name>(\n"
    "    in rangeType_<name>,\n"
    "    in rangeType_<name>,\n"
    "#if domainTypeEnum_<name> == DOUBLE || domainTypeEnum_<name> == UNSIGNED_INT64_NV || domainTypeEnum_<name> == "
    "INT64_NV\n"
    "    in double);\n"
    "#else\n"
    "    in float);\n"
    "#endif\n"
    "subroutine uniform QuantInterpFunc_<name> quantInterp_<name>;\n"
    "subroutine(QuantInterpFunc_<name>) rangeType_<name> defaultInterp_<name>(\n"
    "    in rangeType_<name> v1,\n"
    "    in rangeType_<name> v2,\n"
    "#if domainTypeEnum_<name> == DOUBLE || domainTypeEnum_<name> == UNSIGNED_INT64_NV || domainTypeEnum_<name> == "
    "INT64_NV\n"
    "    in double t) {\n"
    "#else\n"
    "    in float t) {\n"
    "#endif\n"
    "\n"
    "  #if domainTypeEnum_<name> == DOUBLE || domainTypeEnum_<name> == UNSIGNED_INT64_NV || domainTypeEnum_<name> == "
    "INT64_NV\n"
    "    #if rangeTypeEnum_<name> == DOUBLE || rangeTypeEnum_<name> == DOUBLE_VEC2 || rangeTypeEnum_<name> == "
    "DOUBLE_VEC3 || rangeTypeEnum_<name> == DOUBLE_VEC4\n"
    "      return mix(v1, v2, t);\n"
    "    #else\n"
    "      return mix(v1, v2, float(t));\n"
    "    #endif\n"
    "  #else\n"
    "      return mix(v1, v2, t);\n"
    "  #endif // if domainTypeEnum_<name> == DOUBLE\n"
    "}\n"
    "\n"
    "subroutine(QuantInterpFunc_<name>) rangeType_<name> colorInterpHslHcl_<name>(\n"
    "    in rangeType_<name> v1,\n"
    "    in rangeType_<name> v2,\n"
    "#if domainTypeEnum_<name> == DOUBLE || domainTypeEnum_<name> == UNSIGNED_INT64_NV || domainTypeEnum_<name> == "
    "INT64_NV\n"
    "    in double t) {\n"
    "#else\n"
    "    in float t) {\n"
    "#endif\n"
    "  #if rangeTypeEnum_<name> == FLOAT_VEC4\n"
    "    if (abs(v1[0] - v2[0]) > 180.0) {\n"
    "        if (v1[0] < v2[0]) {\n"
    "            v1[0] += 360.0;\n"
    "        } else {\n"
    "            v2[0] += 360.0;\n"
    "        }\n"
    "    }\n"
    "  #endif\n"
    "    return defaultInterp_<name>(v1, v2, t);\n"
    "}\n"
    "\n"
    "subroutine(QuantInterpFunc_<name>) rangeType_<name> colorInterpHslHclLong_<name>(\n"
    "    in rangeType_<name> v1,\n"
    "    in rangeType_<name> v2,\n"
    "#if domainTypeEnum_<name> == DOUBLE || domainTypeEnum_<name> == UNSIGNED_INT64_NV || domainTypeEnum_<name> == "
    "INT64_NV\n"
    "    in double t) {\n"
    "#else\n"
    "    in float t) {\n"
    "#endif\n"
    "  #if rangeTypeEnum_<name> == FLOAT_VEC4\n"
    "    float absval = abs(v1[0] - v2[0]);\n"
    "    if (absval > 0 && absval < 180.0) {\n"
    "        if (v1[0] < v2[0]) {\n"
    "            v2[0] += 360.0;\n"
    "        } else {\n"
    "            v1[0] += 360.0;\n"
    "        }\n"
    "    }\n"
    "  #endif\n"
    "    return defaultInterp_<name>(v1, v2, t);\n"
    "}\n"
    "\n"
    "rangeType_<name> getQuantitativeScale_<name>(in domainType_<name> domainVal) {\n"
    "    domainType_<name> val1;\n"
    "    domainType_<name> val2;\n"
    "    int idx1, idx2;\n"
    "\n"
    "    #if doAccum_QuantitativeScale_<name> == 1\n"
    "        accumIdx = 0;\n"
    "        return uRanges_<name>[accumIdx];\n"
    "    #else\n"
    "      if (isNullValFunc_<name>(domainVal)) {\n"
    "        return nullRangeVal_<name>;\n"
    "      }\n"
    "\n"
    "      domainType_<name> transformedVal = quantTransform_<name>(domainVal);\n"
    "      #if numDomains_<name> == 1 || numRanges_<name> == 1\n"
    "        idx1 = 0;\n"
    "        idx2 = 0;\n"
    "        val1 = uDomains_<name>[0];\n"
    "        val2 = uDomains_<name>[0];\n"
    "      #elif numDomains_<name> == 2 || numRanges_<name> == 2\n"
    "        idx1 = 0;\n"
    "        idx2 = 1;\n"
    "        val1 = uDomains_<name>[0];\n"
    "        val2 = uDomains_<name>[1];\n"
    "      #else\n"
    "        int startIdx = 0;\n"
    "        int endIdx = numDomains_<name> - 1;\n"
    "        domainType_<name> midVal;\n"
    "\n"
    "        if (transformedVal == uDomains_<name>[startIdx]) {\n"
    "            idx1 = startIdx;\n"
    "            idx2 = startIdx+1;\n"
    "        } else if (transformedVal == uDomains_<name>[endIdx]) {\n"
    "            idx1 = endIdx-1;\n"
    "            idx2 = endIdx;\n"
    "        } else {\n"
    "            while (true) {\n"
    "                int midIdx = startIdx + (endIdx - startIdx) / 2;\n"
    "                if (midIdx == startIdx) {\n"
    "                    if (transformedVal == uDomains_<name>[midIdx-1]) {\n"
    "                        idx1 = midIdx - 1;\n"
    "                        idx2 = midIdx;\n"
    "                    } else {\n"
    "                        idx1 = midIdx;\n"
    "                        idx2 = endIdx;\n"
    "                    }\n"
    "                    break;\n"
    "                } else {\n"
    "                    midVal = uDomains_<name>[midIdx];\n"
    "                    if (transformedVal == midVal) {\n"
    "                        if (midVal == uDomains_<name>[midIdx-1]) {\n"
    "                            idx1 = midIdx - 1;\n"
    "                            idx2 = midIdx;\n"
    "                        } else {\n"
    "                            idx1 = midIdx;\n"
    "                            idx2 = midIdx+1;\n"
    "                        }\n"
    "                        break;\n"
    "                    } else if (transformedVal > midVal) {\n"
    "                        startIdx = midIdx;\n"
    "                    } else {\n"
    "                        endIdx = midIdx;\n"
    "                    }\n"
    "                }\n"
    "            }\n"
    "        }\n"
    "\n"
    "        val1 = uDomains_<name>[idx1];\n"
    "        val2 = uDomains_<name>[idx2];\n"
    "      #endif\n"
    "\n"
    "#if domainTypeEnum_<name> == DOUBLE\n"
    "      double t = (transformedVal - val1) / (val2 - val1);\n"
    "#elif domainTypeEnum_<name> == INT64_NV\n"
    "      double t = double(transformedVal - val1) / double(val2 - val1);\n"
    "#elif domainTypeEnum_<name> == UNSIGNED_INT64_NV\n"
    "      double num;\n"
    "      if (transformedVal < val1) {\n"
    "          num = -1 * double(val1 - transformedVal);\n"
    "      } else {\n"
    "          num = double(transformedVal - val1);\n"
    "      }\n"
    "      double t = num / double(val2 - val1);\n"
    "#else\n"
    "      float t = (float(transformedVal) - float(val1)) / (float(val2) - float(val1));\n"
    "#endif\n"
    "      if (isnan(t)) {\n"
    "          t = 0.5;\n"
    "      }\n"
    "\n"
    "      #if useClamp_<name> == 1\n"
    "        t = clamp(t, 0.0, 1.0);\n"
    "      #endif\n"
    "\n"
    "      return quantInterp_<name>(uRanges_<name>[idx1], uRanges_<name>[idx2], t);\n"
    "    #endif // doAccum_QuantitativeScale_<name>\n"
    "}\n";

}  // namespace QueryRenderer

#endif  // QUANTITATIVESCALETEMPLATE_VERT_H_
